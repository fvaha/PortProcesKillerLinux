<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- FIX: Permissive CSP for AppImage JS execution -->
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'self' 'unsafe-inline' 'unsafe-eval' https: http: data: blob: tauri:; connect-src 'self' https: http: tauri: ipc: ws:;">
    <title>PP Killer</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600&family=JetBrains+Mono&display=swap"
        rel="stylesheet">
    <!-- Tailwind CSS CDN - for development only -->
    <!-- In production, use: npm install -D tailwindcss and build with PostCSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        :root {
            --glass-bg: rgba(20, 25, 35, 0.45);
            --sidebar-bg: rgba(255, 255, 255, 0.03);
            --border-white: rgba(255, 255, 255, 0.08);
            --accent: #3b82f6;
            --accent-glow: rgba(59, 130, 246, 0.3);
            --text-main: #f8fafc;
            --text-dim: #94a3b8;
            --green: #10b981;
            --red: #f43f5e;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background: transparent;
            color: var(--text-main);
            height: 100vh;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .app-window {
            width: 100%;
            height: 100%;
            background: var(--glass-bg);
            backdrop-filter: blur(40px) saturate(160%);
            -webkit-backdrop-filter: blur(40px) saturate(160%);
            border: 1px solid var(--border-white);
            display: flex;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            z-index: 10;
        }

        .text-protection {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.15);
            pointer-events: none;
            z-index: 1;
        }

        .sidebar {
            width: 240px;
            min-width: 240px;
            background: var(--sidebar-bg);
            border-right: 1px solid var(--border-white);
            display: flex;
            flex-direction: column;
            padding: 12px 0;
            z-index: 10;
        }

        @media (max-width: 768px) {
            .sidebar {
                width: 64px;
                min-width: 64px;
            }

            .nav-item span,
            .nav-item .nav-text,
            .nav-label,
            .sidebar-footer-text {
                display: none;
            }

            .nav-item {
                justify-content: center;
                padding: 10px 0;
            }

            .nav-item i {
                margin-right: 0;
                font-size: 18px;
            }

            .title-controls {
                flex-direction: column;
                padding: 12px 0;
                align-items: center;
            }

            .linux-btn {
                margin-right: 0;
                margin-bottom: 6px;
            }
        }

        .title-controls {
            padding: 12px 18px;
            display: flex;
            align-items: center;
            -webkit-app-region: drag;
        }

        .linux-btn {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            margin-right: 4px;
            font-size: 11px;
            color: var(--text-dim);
            transition: 0.2s;
            cursor: pointer;
            -webkit-app-region: no-drag;
            z-index: 50;
            position: relative;
        }

        .linux-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .linux-btn.close:hover {
            background: #e81123;
            color: #fff;
        }

        .nav-item {
            padding: 10px 14px;
            margin: 2px 12px;
            border-radius: 8px;
            font-size: 13.5px;
            color: #e2e8f0;
            display: flex;
            align-items: center;
            transition: all 0.2s;
            cursor: pointer;
        }

        .nav-item i {
            width: 22px;
            font-size: 15px;
            margin-right: 12px;
            color: #60a5fa;
        }

        .nav-item:hover,
        .nav-item.active {
            background: rgba(255, 255, 255, 0.06);
            color: #ffffff;
        }

        .nav-item.active {
            background: rgba(59, 130, 246, 0.15);
            color: #93c5fd;
        }

        .nav-item.active i {
            color: #93c5fd;
        }

        .nav-label {
            color: #cbd5e1 !important;
        }

        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            z-index: 5;
            min-width: 0;
        }

        header {
            height: 64px;
            padding: 0 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            -webkit-app-region: drag;
            border-bottom: 1px solid var(--border-white);
            gap: 12px;
        }

        .search-box {
            position: relative;
            flex: 1;
            max-width: 320px;
            -webkit-app-region: no-drag;
        }

        .search-box input {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-white);
            border-radius: 10px;
            padding: 8px 12px 8px 38px;
            font-size: 13px;
            color: #fff;
            outline: none;
        }

        .search-box i {
            position: absolute;
            left: 14px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 14px;
            color: var(--text-dim);
        }

        .table-wrap {
            flex: 1;
            overflow: auto;
            padding: 16px 24px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            min-width: 500px;
        }

        th {
            text-align: left;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-dim);
            text-transform: uppercase;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-white);
            position: sticky;
            top: 0;
            background: rgba(20, 25, 35, 0.8);
            backdrop-filter: blur(10px);
            z-index: 20;
        }

        td {
            padding: 14px 16px;
            font-size: 14px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.02);
        }

        tr:hover td {
            background: rgba(255, 255, 255, 0.03);
        }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(15px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .modal.open {
            display: flex;
        }

        .modal-content {
            background: #111827;
            border: 1px solid var(--border-white);
            border-radius: 20px;
            width: 90%;
            max-width: 480px;
            padding: 36px;
            box-shadow: 0 4px 50px rgba(0, 0, 0, 0.8);
        }

        .action-icon {
            padding: 8px;
            border-radius: 6px;
            color: var(--text-dim);
            cursor: pointer;
            transition: 0.2s;
            -webkit-app-region: no-drag;
        }

        .action-icon:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .action-icon.loading i {
            animation: spin 1s linear infinite;
            color: var(--accent);
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .btn-install {
            background: var(--accent);
            color: white;
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 13px;
            width: 100%;
            transition: 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-install:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }
    </style>
</head>

<body>
    <div class="app-window" id="app-window">
        <div class="text-protection" id="protection-layer"></div>
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="title-controls">
                <div class="linux-btn close" title="Close" id="win-close"><i class="fa-solid fa-xmark"></i></div>
                <div class="linux-btn" title="Minimize" id="win-min"><i class="fa-solid fa-minus"></i></div>
                <div class="linux-btn" title="Maximize" id="win-max"><i class="fa-solid fa-expand"></i></div>
            </div>

            <nav class="mt-8 flex-1 overflow-y-auto">
                <p class="nav-label px-7 text-[10px] font-bold text-slate-500 uppercase tracking-widest mb-3">Views
                </p>
                <div class="nav-item active" onclick="switchView('ports', this)">
                    <i class="fa-solid fa-network-wired"></i> <span class="nav-text">Ports</span>
                </div>
                <div class="nav-item" onclick="switchView('processes', this)">
                    <i class="fa-solid fa-microchip"></i> <span class="nav-text">Processes</span>
                </div>

                <p class="nav-label px-7 text-[10px] font-bold text-slate-500 uppercase tracking-widest mb-3 mt-8">
                    Filters</p>
                <div class="nav-item" onclick="setFilter('all', this)">
                    <i class="fa-solid fa-gauge-high"></i> <span class="nav-text">All</span>
                </div>
                <div class="nav-item" onclick="setFilter('web', this)"><i class="fa-solid fa-globe"></i> <span
                        class="nav-text">Web Apps</span></div>
                <div class="nav-item" onclick="setFilter('database', this)"><i class="fa-solid fa-database"></i> <span
                        class="nav-text">Databases</span></div>
                <div class="nav-item" onclick="setFilter('docker', this)"><i class="fa-brands fa-docker"></i> <span
                        class="nav-text">Docker</span></div>
                <div class="nav-item" onclick="setFilter('high-cpu', this)"><i class="fa-solid fa-fire"></i> <span
                        class="nav-text">High CPU</span></div>
                <div class="nav-item" onclick="setFilter('high-mem', this)"><i class="fa-solid fa-memory"></i> <span
                        class="nav-text">High Memory</span></div>
            </nav>

            <div class="mt-auto px-6 py-4 flex items-center space-x-3 text-slate-300 text-xs">
                <div class="w-2 h-2 rounded-full bg-green-500 shadow-[0_0_8px_rgba(34,197,94,0.5)]"></div>
                <span class="sidebar-footer-text" id="status-text">Service Engine Live</span>
            </div>
        </aside>

        <!-- Main Body -->
        <main class="content main">
            <header>
                <div class="flex items-center space-x-3 min-w-max">
                    <h1 class="text-lg font-semibold tracking-tight">PP Killer</h1>
                    <button id="refresh-btn" class="action-icon" title="Refresh Now"><i
                            class="fa-solid fa-arrow-rotate-right"></i></button>
                </div>

                <div class="search-box">
                    <i class="fa-solid fa-magnifying-glass"></i>
                    <input type="text" placeholder="Search port or process..." id="search-input">
                </div>

                <div class="flex items-center space-x-1 header-actions">
                    <button class="action-icon" id="btn-terminal" title="Terminal"><i
                            class="fa-solid fa-terminal"></i></button>
                    <button class="action-icon" id="btn-settings" title="Settings"><i
                            class="fa-solid fa-gear"></i></button>
                </div>
            </header>

            <div class="table-wrap">
                <!-- Kill all button - only visible in processes view when multiple processes match -->
                <div id="kill-all-container" style="display: none; margin-bottom: 12px; padding: 8px 12px; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px;">
                    <button id="kill-all-app-btn" onclick="killAllProcessesByName()" 
                            style="display: flex; align-items: center; gap: 8px; background: rgba(239, 68, 68, 0.2); border: 1px solid rgba(239, 68, 68, 0.5); 
                                   color: #f87171; padding: 8px 16px; border-radius: 6px; font-size: 12px; 
                                   cursor: pointer; font-weight: 600; transition: all 0.2s; width: 100%; justify-content: center;"
                            onmouseover="this.style.background='rgba(239, 68, 68, 0.3)'" 
                            onmouseout="this.style.background='rgba(239, 68, 68, 0.2)'">
                        <i class="fa-solid fa-skull"></i> <span id="kill-all-text">Kill all</span>
                    </button>
                </div>
                <table>
                    <thead id="table-header">
                        <tr id="ports-header">
                            <th>Port</th>
                            <th>Active Process</th>
                            <th>PID</th>
                            <th>Type</th>
                            <th class="text-right">Manage</th>
                        </tr>
                        <tr id="processes-header" style="display: none;">
                            <th>PID</th>
                            <th>Process Name</th>
                            <th>CPU %</th>
                            <th>Memory %</th>
                            <th>User</th>
                            <th class="text-right">Manage</th>
                        </tr>
                    </thead>
                    <tbody id="ports-table-body"></tbody>
                </table>
            </div>
        </main>
    </div>

    <!-- Settings Modal -->
    <div class="modal" id="settings-modal">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-bold">Settings</h2>
                <button class="text-slate-500 hover:text-white" onclick="closeSettings()"><i
                        class="fa-solid fa-xmark"></i></button>
            </div>

            <div class="space-y-6">
                <!-- Transparency Slider -->
                <div>
                    <div class="flex justify-between mb-2">
                        <label class="block text-xs font-bold text-slate-500 uppercase">Transparency & Blur</label>
                        <span class="text-[10px] text-slate-400" id="opacity-val">45%</span>
                    </div>
                    <input type="range" min="10" max="95" value="45" id="opacity-slider"
                        oninput="updateOpacity(this.value)">
                </div>

                <!-- Auto Refresh Slider -->
                <div class="border-t border-white/5 pt-6">
                    <div class="flex justify-between mb-2">
                        <label class="block text-xs font-bold text-slate-500 uppercase">Auto Refresh Interval</label>
                        <span class="text-[10px] text-slate-400" id="refresh-val">5s</span>
                    </div>
                    <input type="range" min="1" max="60" value="5" id="refresh-slider"
                        oninput="updateRefreshInterval(this.value)">
                    <p class="text-[9px] text-slate-500 mt-1">Set to 1s for real-time or 60s for 1 minute intervals.</p>
                </div>

                <!-- Waybar Integration -->
                <div class="border-t border-white/5 pt-6">
                    <div class="flex items-center gap-2 mb-3">
                        <label class="block text-xs font-bold text-slate-500 uppercase">Waybar Integration</label>
                        <span
                            class="px-1.5 py-0.5 rounded bg-amber-500/10 text-amber-500 text-[8px] font-bold uppercase tracking-tighter">Experimental</span>
                    </div>
                    <p class="text-[11px] text-slate-400 mb-4 leading-relaxed">
                        Automatically add the PP Killer module and styling to your Waybar.
                        <span class="text-amber-500/80">Risky: This modifies your config files. Use at your own
                            risk.</span>
                    </p>
                    <button class="btn-install" id="btn-setup-waybar">
                        <i class="fa-solid fa-wand-magic-sparkles"></i>
                        One-Click Install Module
                    </button>
                    <div id="waybar-msg" class="text-[10px] mt-2 text-center"></div>
                </div>

                <!-- About Section -->
                <div class="border-t border-white/5 pt-6">
                    <h3 class="text-sm font-bold mb-1">About PP Killer</h3>
                    <p class="text-[11px] text-slate-400">Created by: <b>Vahid E.</b> | <a href="https://vaha.net"
                            target="_blank" class="text-blue-400">vaha.net</a></p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let isRefreshing = false; // Prevent multiple simultaneous refreshes
        
        // Wait for Tauri API to be available
        // Use window object to avoid shadowing issues
        window.isTauri = false;
        let invoke = null;
        let getCurrentWindow = null;

        function initTauriAPI() {
            console.log("=== Initializing Tauri API ===");
            console.log("window.__TAURI__:", window.__TAURI__);
            console.log("window.__TAURI_INTERNALS__:", window.__TAURI_INTERNALS__);
            
            // Check multiple ways Tauri might be available
            if (window.__TAURI__) {
                window.isTauri = true;
                console.log("Found window.__TAURI__");
                console.log("window.__TAURI__ keys:", Object.keys(window.__TAURI__));
                
                if (window.__TAURI__.core && window.__TAURI__.core.invoke) {
                    invoke = window.__TAURI__.core.invoke;
                    console.log("✓ Found invoke at window.__TAURI__.core.invoke");
                } else if (window.__TAURI__.invoke) {
                    invoke = window.__TAURI__.invoke;
                    console.log("✓ Found invoke at window.__TAURI__.invoke");
                } else {
                    console.warn("✗ invoke not found in window.__TAURI__");
                }
                
                if (window.__TAURI__.window && window.__TAURI__.window.getCurrentWindow) {
                    getCurrentWindow = window.__TAURI__.window.getCurrentWindow;
                    console.log("✓ Found getCurrentWindow at window.__TAURI__.window.getCurrentWindow");
                } else {
                    console.warn("✗ getCurrentWindow not found in window.__TAURI__.window");
                }
            } else if (window.__TAURI_INTERNALS__) {
                window.isTauri = true;
                console.log("Found window.__TAURI_INTERNALS__");
                // Try alternative API location
                if (window.__TAURI_INTERNALS__.core && window.__TAURI_INTERNALS__.core.invoke) {
                    invoke = window.__TAURI_INTERNALS__.core.invoke;
                    console.log("✓ Found invoke at window.__TAURI_INTERNALS__.core.invoke");
                }
            } else {
                console.warn("✗ Tauri API not found - not running in Tauri environment");
            }

            if (!invoke) {
                invoke = () => {
                    console.error("Tauri invoke not available. API not loaded.");
                    return Promise.reject("Tauri API not available");
                };
            }

            if (!getCurrentWindow) {
                getCurrentWindow = () => null;
            }

            console.log("=== Tauri API Initialization Complete ===");
            console.log("isTauri:", window.isTauri);
            console.log("invoke available:", !!invoke);
            console.log("getCurrentWindow available:", !!getCurrentWindow);
            
            // Test invoke if available
            if (invoke) {
                console.log("Testing invoke with a simple call...");
                invoke('get_ports')
                    .then(result => {
                        console.log("✓ Test invoke successful! Result:", result);
                    })
                    .catch(err => {
                        console.error("✗ Test invoke failed:", err);
                    });
            }
        }

        // Try to initialize immediately
        initTauriAPI();

        // Also try after DOM loads (in case Tauri loads later)
        window.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded, checking Tauri again...");
            initTauriAPI();
            // Try again after a short delay
            setTimeout(initTauriAPI, 100);
            setTimeout(initTauriAPI, 500);
        });

        // Listen for Tauri ready event if available
        if (window.addEventListener) {
            window.addEventListener('tauri://ready', () => {
                console.log("Tauri ready event received");
                initTauriAPI();
            });
        }

        // Global Error Handler for debugging
        window.onerror = function (msg, url, lineNo, columnNo, error) {
            console.error('=== WINDOW ERROR ===');
            console.error('Message:', msg);
            console.error('Line:', lineNo, 'Column:', columnNo);
            console.error('URL:', url);
            console.error('Error object:', error);
            console.error('Stack:', error?.stack);
            console.error('===================');
            
            // Also show in UI for visibility
            const statusText = document.getElementById('status-text');
            if (statusText) {
                statusText.innerText = `ERROR: ${msg} (Line ${lineNo})`;
                statusText.style.color = '#f43f5e';
            }
            
            return false;
        };

        window.onunhandledrejection = function (event) {
            console.error('=== UNHANDLED PROMISE REJECTION ===');
            console.error('Reason:', event.reason);
            console.error('Promise:', event.promise);
            console.error('===================================');
            
            const statusText = document.getElementById('status-text');
            if (statusText) {
                statusText.innerText = `PROMISE ERROR: ${event.reason}`;
                statusText.style.color = '#f43f5e';
            }
        };

        async function initWindow() {
            if (!window.isTauri) {
                console.log("Not running in Tauri environment. Window controls disabled.");
                return;
            }

            if (!getCurrentWindow) {
                console.warn("getCurrentWindow not available");
                return;
            }

            try {
                const appWindow = getCurrentWindow();
                if (!appWindow) {
                    console.warn("Failed to get app window");
                    return;
                }
                console.log("Window controls initialized");

                const closeBtn = document.getElementById('win-close');
                const minBtn = document.getElementById('win-min');
                const maxBtn = document.getElementById('win-max');

                if (closeBtn) {
                    closeBtn.onclick = async (e) => {
                        try {
                            console.log("Close clicked");
                            await appWindow.close();
                        } catch (err) {
                            console.error("Failed to close window:", err);
                        }
                    };
                }

                if (minBtn) {
                    minBtn.onclick = async (e) => {
                        try {
                            console.log("Minimize clicked");
                            await appWindow.minimize();
                        } catch (err) {
                            console.error("Failed to minimize window:", err);
                        }
                    };
                }

                if (maxBtn) {
                    maxBtn.onclick = async (e) => {
                        try {
                            console.log("Maximize clicked");
                            if (await appWindow.isMaximized()) await appWindow.unmaximize();
                            else await appWindow.maximize();
                        } catch (err) {
                            console.error("Failed to maximize window:", err);
                        }
                    };
                }
            } catch (err) {
                console.error("Failed to initialize window controls:", err);
            }
        }

        // Wait a bit for Tauri to fully load
        setTimeout(() => {
            initWindow();
        }, 100);


        document.getElementById('btn-terminal').onclick = async () => {
            try {
                await invoke('open_terminal');
            } catch (err) {
                console.error("Failed to open terminal:", err);
            }
        };
        document.getElementById('btn-settings').onclick = () => {
            console.log("Settings button clicked");
            const modal = document.getElementById('settings-modal');
            if (modal) {
                modal.classList.add('open');
                console.log("Settings modal opened");
            } else {
                console.error("Settings modal not found!");
            }
        };

        window.closeSettings = function() { document.getElementById('settings-modal').classList.remove('open'); }

        function updateOpacity(val) {
            const opacity = val / 100;
            document.documentElement.style.setProperty('--glass-bg', `rgba(20, 25, 35, ${opacity})`);
            document.getElementById('protection-layer').style.background = `rgba(0, 0, 0, ${opacity * 0.4})`;
            document.getElementById('opacity-val').innerText = val + '%';
        }

        let refreshInterval = 5000;
        let refreshTimer = null;

        function updateRefreshInterval(val) {
            refreshInterval = val * 1000;
            document.getElementById('refresh-val').innerText = val + 's';
            startAutoRefresh();
        }

        function startAutoRefresh() {
            if (refreshTimer) clearInterval(refreshTimer);
            refreshTimer = setInterval(window.refreshCurrentView, refreshInterval);
        }

        async function doWaybarSetup() {
            if (!confirm("EXPERIMENTAL FEATURE:\n\nThis will attempt to modify your ~/.config/waybar/config and style.css files.\nProceed at your own risk?")) return;
            const btn = document.getElementById('btn-setup-waybar');
            btn.disabled = true;
            try {
                if (!invoke) {
                    throw new Error("Tauri API not loaded");
                }
                const result = await invoke('setup_waybar');
                document.getElementById('waybar-msg').className = 'text-green-400 text-[10px] mt-2 text-center';
                document.getElementById('waybar-msg').innerText = result;
            } catch (err) {
                console.error("Error setting up waybar:", err);
                document.getElementById('waybar-msg').className = 'text-red-400 text-[10px] mt-2 text-center';
                document.getElementById('waybar-msg').innerText = "Error: " + (err.message || err);
            }
            btn.disabled = false;
        }

        document.getElementById('btn-setup-waybar').onclick = doWaybarSetup;

        let allPorts = [];
        let allProcesses = [];
        let currentFilter = 'all';
        let currentView = 'ports';

        // Make functions globally available for onclick handlers
        window.switchView = function(view, el) {
            console.log("=== switchView called ===");
            console.log("View:", view);
            console.log("Current view before switch:", currentView);
            
            currentView = view;

            // Update active nav item - only for view items
            const viewItems = document.querySelectorAll('.nav-item');
            viewItems.forEach(item => {
                const onclick = item.getAttribute('onclick');
                if (onclick && onclick.includes('switchView')) {
                    item.classList.remove('active');
                }
            });
            el.classList.add('active');

            // Toggle table headers
            if (view === 'ports') {
                console.log("Switching to ports view...");
                const portsHeader = document.getElementById('ports-header');
                const processesHeader = document.getElementById('processes-header');
                if (portsHeader) portsHeader.style.display = '';
                if (processesHeader) processesHeader.style.display = 'none';
                
                // Always fetch fresh data when switching to ports
                console.log("Calling fetchPorts()...");
                fetchPorts();
            } else {
                console.log("Switching to processes view...");
                const portsHeader = document.getElementById('ports-header');
                const processesHeader = document.getElementById('processes-header');
                if (portsHeader) portsHeader.style.display = 'none';
                if (processesHeader) processesHeader.style.display = '';
                
                console.log("Calling fetchProcesses()...");
                fetchProcesses();
                // Ažuriraj "Kill all" opciju nakon prebacivanja na processes view
                setTimeout(updateKillAllOption, 100);
            }
        }

        window.refreshCurrentView = function() {
            if (currentView === 'ports') {
                fetchPorts();
            } else {
                fetchProcesses();
            }
        }

        async function fetchPorts() {
            if (isRefreshing) {
                console.log("Already refreshing, skipping...");
                return;
            }
            
            isRefreshing = true;
            console.log("=== fetchPorts() called ===");
            const refreshBtn = document.getElementById('refresh-btn');
            if (refreshBtn) refreshBtn.classList.add('loading');
            
            try {
                if (!invoke) {
                    console.error("✗ Invoke function not available");
                    const statusText = document.getElementById('status-text');
                    if (statusText) {
                        statusText.innerText = "Tauri API not loaded";
                        statusText.style.color = '#f43f5e';
                    }
                    return;
                }
                
                console.log("✓ Invoke available, calling get_ports...");
                console.log("Invoke function type:", typeof invoke);
                
                const result = await invoke('get_ports');
                console.log("✓ Received response from get_ports");
                console.log("Response type:", typeof result);
                console.log("Response:", result);
                console.log("Is array:", Array.isArray(result));
                console.log("Length:", result?.length || 0);
                
                allPorts = result || [];
                console.log("allPorts set to:", allPorts);
                
                renderPorts();
                
                const statusText = document.getElementById('status-text');
                if (statusText) {
                    statusText.innerText = "Last sync: " + new Date().toLocaleTimeString();
                    statusText.style.color = '';
                }
            } catch (err) {
                console.error("✗ Error fetching ports:", err);
                console.error("Error name:", err.name);
                console.error("Error message:", err.message);
                console.error("Error stack:", err.stack);
                
                const statusText = document.getElementById('status-text');
                if (statusText) {
                    statusText.innerText = "Error: " + (err.message || err);
                    statusText.style.color = '#f43f5e';
                }
            }
            finally { 
                isRefreshing = false;
                if (refreshBtn) {
                    setTimeout(() => refreshBtn.classList.remove('loading'), 1000);
                }
            }
        }

        async function fetchProcesses() {
            if (isRefreshing) {
                console.log("Already refreshing, skipping...");
                return;
            }
            
            isRefreshing = true;
            const refreshBtn = document.getElementById('refresh-btn');
            if (refreshBtn) refreshBtn.classList.add('loading');
            try {
                if (!invoke) {
                    console.error("Invoke function not available");
                    document.getElementById('status-text').innerText = "Tauri API not loaded";
                    return;
                }
                console.log("Calling get_processes...");
                allProcesses = await invoke('get_processes');
                console.log("Received processes:", allProcesses?.length || 0);
                renderProcesses();
                // Ažuriraj "Kill all" opciju nakon renderovanja procesa
                setTimeout(updateKillAllOption, 100);
                document.getElementById('status-text').innerText = "Last sync: " + new Date().toLocaleTimeString();
            } catch (err) {
                console.error("Error fetching processes:", err);
                document.getElementById('status-text').innerText = "Error fetching processes: " + (err.message || err);
            }
            finally { 
                isRefreshing = false;
                if (refreshBtn) {
                    setTimeout(() => refreshBtn.classList.remove('loading'), 1000);
                }
            }
        }

        window.setFilter = function(type, el) {
            currentFilter = type;

            // Update active nav item - only for filter items
            const filterItems = document.querySelectorAll('.nav-item');
            filterItems.forEach(item => {
                const onclick = item.getAttribute('onclick');
                if (onclick && onclick.includes('setFilter')) {
                    item.classList.remove('active');
                }
            });
            el.classList.add('active');

            // Apply filter to current view
            if (currentView === 'ports') {
                renderPorts();
            } else {
                renderProcesses();
                updateKillAllOption(); // Ažuriraj "Kill all" opciju nakon promene filtera
            }
        }

        function renderPorts() {
            console.log("=== renderPorts() called ===");
            console.log("allPorts:", allPorts);
            console.log("allPorts length:", allPorts?.length || 0);
            console.log("currentView:", currentView);
            
            // Make sure we're in ports view
            if (currentView !== 'ports') {
                console.warn("renderPorts called but currentView is:", currentView, "- skipping render");
                return;
            }
            
            const body = document.getElementById('ports-table-body');
            if (!body) {
                console.error("✗ ports-table-body not found!");
                return;
            }
            
            // Make sure ports header is visible
            const portsHeader = document.getElementById('ports-header');
            const processesHeader = document.getElementById('processes-header');
            if (portsHeader) {
                portsHeader.style.display = '';
                console.log("✓ Ports header made visible");
            }
            if (processesHeader) {
                processesHeader.style.display = 'none';
                console.log("✓ Processes header hidden");
            }
            
            const query = document.getElementById('search-input')?.value.toLowerCase() || '';
            console.log("Search query:", query);

            let filtered = allPorts.filter(p => p.port.includes(query) || (p.process_name || '').toLowerCase().includes(query));

            if (currentFilter === 'web') {
                filtered = filtered.filter(p => [80, 443, 3000, 5000, 8000, 8080, 4200, 5173].includes(parseInt(p.port)));
            } else if (currentFilter === 'database') {
                filtered = filtered.filter(p => [3306, 5432, 27017, 6379, 1433, 8086, 9200, 9042, 5984, 5433, 1521, 26379].includes(parseInt(p.port)));
            } else if (currentFilter === 'docker') {
                filtered = filtered.filter(p => (p.process_name || '').toLowerCase().includes('docker') || (p.process_name || '').toLowerCase().includes('containerd'));
            }
            // Note: high-cpu and high-mem filters don't apply to ports view

            body.innerHTML = '';
            if (filtered.length === 0) {
                console.log("No ports to display (filtered array is empty)");
                body.innerHTML = '<tr><td colspan="5" class="text-center text-slate-500 py-8">No ports found</td></tr>';
                return;
            }
            
            console.log("Rendering", filtered.length, "ports");

            filtered.forEach(p => {
                const tr = document.createElement('tr');
                const isSystem = parseInt(p.port) < 1024;
                const isDocker = (p.process_name || '').toLowerCase().includes('docker');

                tr.innerHTML = `
                    <td class="font-mono text-blue-400 font-bold">:${p.port}</td>
                    <td class="font-medium truncate max-w-[120px]" title="${p.process_name}">${p.process_name || 'unknown'} ${isDocker ? '<i class="fa-brands fa-docker text-blue-400 ml-1"></i>' : ''}</td>
                    <td class="text-slate-500 font-mono text-xs">${p.pid || '-'}</td>
                    <td><span class="px-2 py-0.5 rounded-full text-[10px] uppercase font-bold ${isDocker ? 'bg-blue-500/20 text-blue-300' : isSystem ? 'bg-orange-500/10 text-orange-400' : 'bg-blue-500/10 text-blue-400'}">${isDocker ? 'Docker' : isSystem ? 'System' : 'User App'}</span></td>
                    <td class="text-right"><button class="action-icon hover:text-red-500" onclick="killProc(${p.pid})"><i class="fa-solid fa-circle-xmark"></i></button></td>
                `;
                body.appendChild(tr);
            });
        }

        function renderProcesses() {
            const body = document.getElementById('ports-table-body');
            const query = document.getElementById('search-input').value.toLowerCase();

            let filtered = allProcesses.filter(p =>
                p.name.toLowerCase().includes(query) ||
                p.pid.toString().includes(query) ||
                p.user.toLowerCase().includes(query)
            );

            // Apply filters
            if (currentFilter === 'high-cpu') {
                filtered = filtered.filter(p => parseFloat(p.cpu) > 50);
                // Sortiraj po CPU (opadajuće)
                filtered.sort((a, b) => {
                    const cpuA = parseFloat(a.cpu) || 0;
                    const cpuB = parseFloat(b.cpu) || 0;
                    return cpuB - cpuA;
                });
            } else if (currentFilter === 'high-mem') {
                filtered = filtered.filter(p => parseFloat(p.mem) > 1000); // > 1GB
                // Sortiraj po memoriji (opadajuće)
                filtered.sort((a, b) => {
                    const memA = parseFloat(a.mem) || 0;
                    const memB = parseFloat(b.mem) || 0;
                    return memB - memA;
                });
            } else if (currentFilter === 'web') {
                filtered = filtered.filter(p => ['node', 'npm', 'yarn', 'pnpm', 'python', 'php', 'apache', 'nginx', 'httpd'].some(term => p.name.toLowerCase().includes(term)));
            } else if (currentFilter === 'database') {
                filtered = filtered.filter(p => ['mysql', 'postgres', 'mongodb', 'redis', 'mariadb', 'sqlite', 'cassandra'].some(term => p.name.toLowerCase().includes(term)));
            } else if (currentFilter === 'docker') {
                filtered = filtered.filter(p => p.name.toLowerCase().includes('docker') || p.name.toLowerCase().includes('containerd'));
            } else if (currentFilter === 'all') {
                // Sortiraj po CPU opadajuće za "All" filter
                filtered.sort((a, b) => {
                    const cpuA = parseFloat(a.cpu) || 0;
                    const cpuB = parseFloat(b.cpu) || 0;
                    return cpuB - cpuA;
                });
            }

            body.innerHTML = '';
            if (filtered.length === 0) {
                body.innerHTML = '<tr><td colspan="6" class="text-center text-slate-500 py-8">No processes found</td></tr>';
                // Ažuriraj "Kill all" opciju čak i kada nema rezultata
                updateKillAllOption();
                return;
            }

            // Use DocumentFragment for better performance
            const fragment = document.createDocumentFragment();
            
            filtered.forEach(p => {
                const tr = document.createElement('tr');
                const cpuFloat = parseFloat(p.cpu);
                const memFloat = parseFloat(p.mem); // This is in MB, not percentage
                const isHighCpu = cpuFloat > 50;
                const isHighMem = memFloat > 1000; // High memory if > 1GB

                // Format CPU nicely (ensure it's a percentage)
                const cpuDisplay = cpuFloat.toFixed(1) + '%';

                // Format memory nicely
                let memDisplay = '';
                if (memFloat >= 1024) {
                    memDisplay = (memFloat / 1024).toFixed(1) + ' GB';
                } else {
                    memDisplay = memFloat.toFixed(1) + ' MB';
                }

                tr.innerHTML = `
                    <td class="font-mono text-blue-400 font-bold">${p.pid}</td>
                    <td class="font-medium truncate max-w-[200px]" title="${p.name}">${p.name}</td>
                    <td class="font-mono text-xs ${isHighCpu ? 'text-red-400 font-bold' : 'text-slate-400'}" title="CPU Usage: ${cpuDisplay}">${cpuDisplay}</td>
                    <td class="font-mono text-xs ${isHighMem ? 'text-orange-400 font-bold' : 'text-slate-400'}" title="${memFloat.toFixed(1)} MB">${memDisplay}</td>
                    <td class="text-slate-500 text-xs">${p.user}</td>
                    <td class="text-right"><button class="action-icon hover:text-red-500" onclick="killProcess(${p.pid})"><i class="fa-solid fa-circle-xmark"></i></button></td>
                `;
                fragment.appendChild(tr);
            });
            
            body.appendChild(fragment);
        }

        window.killProc = async function(pid) {
            if (!pid) return;
            if (!confirm(`Kill process with PID ${pid}?`)) return;
            try {
                if (!invoke) {
                    console.error("Invoke function not available");
                    alert("Tauri API not loaded");
                    return;
                }
                await invoke('kill_port', { pid });
                setTimeout(window.refreshCurrentView, 500);
            } catch (err) {
                console.error("Error killing port:", err);
                alert("Failed to kill process: " + (err.message || err));
            }
        }

        window.killProcess = async function(pid) {
            if (!pid) return;
            if (!confirm(`Kill process with PID ${pid}?`)) return;
            try {
                if (!invoke) {
                    console.error("Invoke function not available");
                    alert("Tauri API not loaded");
                    return;
                }
                await invoke('kill_process', { pid });
                setTimeout(window.refreshCurrentView, 500);
            } catch (err) {
                console.error("Error killing process:", err);
                alert("Failed to kill process: " + (err.message || err));
            }
        }

        document.getElementById('refresh-btn').onclick = () => {
            console.log("Refresh button clicked");
            console.log("Current view:", currentView);
            console.log("invoke available:", !!invoke);
            window.refreshCurrentView();
        };
        document.getElementById('search-input').oninput = () => {
            if (currentView === 'ports') {
                renderPorts();
            } else {
                renderProcesses();
                updateKillAllOption(); // Prikaži "Kill all" samo u processes view
            }
        };

        window.updateKillAllOption = function() {
            // Prikaži samo u processes view
            const killAllContainer = document.getElementById('kill-all-container');
            if (currentView !== 'processes') {
                if (killAllContainer) killAllContainer.style.display = 'none';
                return;
            }
            
            const query = document.getElementById('search-input')?.value.trim() || '';
            
            if (!killAllContainer) {
                console.warn('kill-all-container not found in DOM');
                return;
            }
            
            if (query.length < 2) {
                killAllContainer.style.display = 'none';
                return;
            }
            
            // Proveri da li ima procesa sa tim imenom u svim procesima (ne samo filtriranim)
            if (!allProcesses || allProcesses.length === 0) {
                killAllContainer.style.display = 'none';
                return;
            }
            
            // Pronađi sve procese koji se poklapaju sa upitom
            const matchingProcesses = allProcesses.filter(p => 
                p.name.toLowerCase().includes(query.toLowerCase())
            );
            
            // Prikaži dugme samo ako ima VIŠE od jednog procesa sa tim imenom
            if (matchingProcesses.length > 1) {
                // Pronađi najčešće ime procesa (ako ima više različitih, uzmi prvo)
                const processNames = [...new Set(matchingProcesses.map(p => p.name))];
                const appName = processNames[0]; // Uzmi prvo ime kao naziv aplikacije
                
                const killAllText = document.getElementById('kill-all-text');
                if (killAllText) {
                    killAllText.textContent = `Kill all ${matchingProcesses.length} "${appName}" processes`;
                }
                killAllContainer.style.display = 'block';
                console.log(`Showing kill all button for ${matchingProcesses.length} "${appName}" processes`);
            } else {
                killAllContainer.style.display = 'none';
            }
        };

        window.killAllProcessesByName = async function() {
            const query = document.getElementById('search-input')?.value.trim() || '';
            if (!query || query.length < 2) return;
            
            // Pronađi sve procese koji se poklapaju sa upitom
            if (!allProcesses || allProcesses.length === 0) {
                alert('No processes available');
                return;
            }
            
            const matchingProcesses = allProcesses.filter(p => 
                p.name.toLowerCase().includes(query.toLowerCase())
            );
            
            if (matchingProcesses.length === 0) {
                alert('No processes found matching your search');
                return;
            }
            
            // Pronađi najčešće ime procesa (ako ima više različitih, uzmi prvo)
            const processNames = [...new Set(matchingProcesses.map(p => p.name))];
            const appName = processNames[0]; // Koristi tačno ime aplikacije
            
            if (!confirm(`Kill all ${matchingProcesses.length} "${appName}" processes?`)) {
                return;
            }
            
            try {
                if (!invoke) {
                    alert("Tauri API not loaded");
                    return;
                }
                // Koristi tačno ime aplikacije, ne query
                const result = await invoke('kill_processes_by_name', { processName: appName });
                alert(`Successfully killed ${result} "${appName}" process(es)`);
                setTimeout(window.refreshCurrentView, 500);
            } catch (err) {
                console.error("Error killing processes:", err);
                alert("Failed to kill processes: " + (err.message || err));
            }
        };

        // Initial load - wait for Tauri to be ready
        console.log("Setting up initial load...");
        
        function tryInitialLoad() {
            console.log("=== Attempting initial load ===");
            console.log("invoke available:", !!invoke);
            console.log("isTauri:", window.isTauri);
            console.log("window.__TAURI__:", !!window.__TAURI__);
            
            if (invoke) {
                console.log("✓ Invoke available, starting fetchPorts...");
                fetchPorts();
                startAutoRefresh();
            } else {
                console.error("✗ Invoke not available yet");
                const statusText = document.getElementById('status-text');
                if (statusText) {
                    statusText.innerText = "Waiting for Tauri API...";
                    statusText.style.color = '#fbbf24';
                }
                // Retry after a delay
                setTimeout(tryInitialLoad, 500);
            }
        }
        
        // Try immediately if DOM is already loaded
        if (document.readyState === 'loading') {
            window.addEventListener('DOMContentLoaded', () => {
                console.log("DOM Content Loaded");
                setTimeout(tryInitialLoad, 500);
            });
        } else {
            console.log("DOM already loaded");
            setTimeout(tryInitialLoad, 500);
        }
    </script>
</body>

</html>